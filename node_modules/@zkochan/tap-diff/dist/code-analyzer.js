'use strict';

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Utils = require('./utils');

var blackLineR = /^(?:\s)*$/;

var CodeAnalyzer = function () {
  function CodeAnalyzer(regExpOfTerminators) {
    (0, _classCallCheck3.default)(this, CodeAnalyzer);

    this.regExpOfTerminators = regExpOfTerminators;
  }

  (0, _createClass3.default)(CodeAnalyzer, [{
    key: 'analyze',
    value: function analyze(sourceCode) {
      var lines = sourceCode.split('\n');
      var tree = {
        nodes: []
      };
      var stack = [];
      var retval = [];

      var indentLevel = 0;
      var indentSize = null;

      for (var i = 0; i < lines.length; i++) {
        if (i + 1 === lines.length && lines[i] === '') {
          continue;
        }
        var line_ = lines[i];
        var line = lines[i] + '\n';

        // Initialize the indentSize
        if (indentSize === null) {
          var l = Utils.indentLevel(line_, 1);
          if (l !== 0) indentSize = l;
        }

        var level = Utils.indentLevel(line_, indentSize === null ? 1 : indentSize);
        if (indentLevel + 1 === level) {
          // When enter the nested block
          var _tree = {
            nodes: [line]
          };

          while (stack.length > level) {
            stack.pop();
          }
          if (stack.length === 0) {
            var p = { nodes: [] };
            retval.push(p);
            stack.push(p);
          }
          stack[stack.length - 1].nodes.push(_tree);
          stack.push(_tree);

          indentLevel = level;
        } else if (indentLevel - 1 === level) {
          // When leave the nested block

          while (stack.length > level + 1) {
            stack.pop();
          }

          if (this.regExpOfTerminators.test(line)) {
            // When the line works as a terminator
            stack[stack.length - 1].nodes.push(line);
          } else {
            stack[stack.length - 1] = {
              nodes: [line]
            };
          }

          indentLevel = level;
        } else {
          if (stack.length < indentLevel + 1) {
            var _tree2 = { nodes: [] };

            if (indentLevel === 0) {
              retval.push(_tree2);
            } else {
              stack[indentLevel - 1].nodes.push(_tree2);
            }
            stack[indentLevel] = _tree2;
          }

          stack[indentLevel].nodes.push(line);
          if (blackLineR.test(line)) {
            // When the line is blank
            while (stack.length > indentLevel) {
              stack.pop();
            }
          }
        }
      }

      return retval;
    }
  }]);
  return CodeAnalyzer;
}();

module.exports = CodeAnalyzer;