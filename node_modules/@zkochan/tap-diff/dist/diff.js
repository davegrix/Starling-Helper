'use strict';

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CodeAnalyzer = require('./code-analyzer');
var arrayDiff = require('./array-diff');
var textualDiff = require('./textual-diff');

var defaultAnalyzer = new CodeAnalyzer(/\W+/);
var defaultSimilarityThreshold = 0.8;

module.exports = function (lhs, rhs, options) {
  options = options || {};
  var similarityThreshold = options.similarityThreshold || defaultSimilarityThreshold;
  var analyzer = options.analyzer || defaultAnalyzer;

  // Obtain the trees of lhs and rhs.
  var lTree = analyzer.analyze(lhs);
  var rTree = analyzer.analyze(rhs);

  // Stringify a node
  var stringify = function stringify(n) {
    if (typeof n === 'string') {
      return n;
    }
    var nodes = n.nodes || [];
    return nodes.map(function (v) {
      return stringify(v);
    }).join('');
  };
  var equalsBetweenNodes = function equalsBetweenNodes(n1, n2) {
    return stringify(n1) === stringify(n2);
  };
  var similarity = function similarity(n1, n2) {
    var s1 = n1.map(function (v) {
      if (typeof v === 'string') {
        return v;
      }
      return v.nodes.filter(function (c) {
        return typeof c === 'string';
      }).join('');
    }).join('');
    var s2 = n2.map(function (v) {
      if (typeof v === 'string') {
        return v;
      }
      return v.nodes.filter(function (c) {
        return typeof c === 'string';
      }).join('');
    }).join('');

    // Calculate LCS (the longest common subsequence) of s1 and s2
    // TODO: should calculate LCS by using words instead of characters
    //// Initialize a table
    var table = new Array(s1.length + 1);
    for (var i = 0; i < table.length; i++) {
      table[i] = new Array(s2.length + 1);
    }
    for (var _i = 0; _i < s1.length; _i++) {
      for (var j = 0; j < s2.length; j++) {
        table[_i][j] = table[_i][j] || 0;
        table[_i][j + 1] = table[_i][j + 1] || 0;
        table[_i + 1][j] = table[_i + 1][j] || 0;

        var match = s1.charAt(_i) == s2.charAt(j) ? 1 : 0;
        table[_i + 1][j + 1] = Math.max(table[_i][j] + match, table[_i][j + 1], table[_i + 1][j]);
      }
    }
    var lcs = table[s1.length][s2.length];

    return lcs * 1.0 / Math.min(s1.length, s2.length);
  };

  var retval_ = [];
  var addDelta = function addDelta(delta) {
    var value = delta.value.map(function (v) {
      return stringify(v);
    }).join('');
    if (delta.removed) {
      retval_.push({
        added: undefined,
        removed: true,
        value: value
      });
    } else if (delta.added) {
      retval_.push({
        added: true,
        removed: undefined,
        value: value
      });
    } else {
      retval_.push({
        value: value
      });
    }
  };
  var calculateDiff = function calculateDiff(tree1, tree2) {
    // Calculate the difference between nodes
    var diff = arrayDiff(tree1.nodes, tree2.nodes, equalsBetweenNodes);
    // Add deltas to retval_
    var removedNode = null;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(diff), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var delta = _step.value;

        if (removedNode !== null) {
          if (delta.added && similarity(removedNode.value, delta.value) >= similarityThreshold) {
            // If replace from removedNode to delta and they are similar
            var n1_ = removedNode.value.map(function (v) {
              return v.nodes || [v];
            });
            var n2_ = delta.value.map(function (v) {
              return v.nodes || [v];
            });
            // Flatten n1_ and n2_
            var n1 = Array.prototype.concat.apply([], n1_);
            var n2 = Array.prototype.concat.apply([], n2_);

            if (n1.every(function (v) {
              return typeof v === 'string';
            }) && n2.every(function (v) {
              return typeof v === 'string';
            })) {
              var tdiff = textualDiff(n1.join(''), n2.join(''));
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = (0, _getIterator3.default)(tdiff), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var d = _step2.value;

                  if (d.removed) {
                    retval_.push({
                      added: undefined,
                      removed: true,
                      value: d.value
                    });
                  } else if (d.added) {
                    retval_.push({
                      added: true,
                      removed: undefined,
                      value: d.value
                    });
                  } else {
                    retval_.push({
                      value: d.value
                    });
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            } else {
              var t1 = { nodes: Array.prototype.concat.apply([], n1.map(function (v) {
                  return v.nodes || [v];
                })) };
              var t2 = { nodes: Array.prototype.concat.apply([], n2.map(function (v) {
                  return v.nodes || [v];
                })) };
              // Calculate differences recursively if two nodes are similar
              calculateDiff(t1, t2);
            }

            removedNode = null;
            continue;
          } else {
            addDelta(removedNode);
            removedNode = null;
          }
        }
        if (delta.removed) {
          removedNode = delta;
          continue;
        }

        addDelta(delta);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };
  calculateDiff({ nodes: lTree }, { nodes: rTree });

  // Simplify retval_
  var retval = [];
  var latest = null;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = (0, _getIterator3.default)(retval_), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var delta = _step3.value;

      if (latest === null) {
        latest = delta;
        continue;
      }

      if (latest.removed && delta.removed) {
        latest.value += delta.value;
      } else if (latest.added && delta.added) {
        latest.value += delta.value;
      } else if (latest.removed === undefined && latest.added == undefined && delta.removed === undefined && delta.added == undefined) {
        latest.value += delta.value;
      } else {
        retval.push(latest);
        latest = delta;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (latest !== null) {
    retval.push(latest);
  }

  return retval;
};