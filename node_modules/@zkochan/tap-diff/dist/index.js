'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

exports.default = createReporter;

require('core-js/es6/string');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var diff = require('diff');
var chalk = require('chalk');
var duplexer = require('duplexer');
var figures = require('figures');
var through2 = require('through2');
var parser = require('tap-parser');
var prettyMs = require('pretty-ms');
var jsondiffpatch = require('jsondiffpatch');
var pdiff = require('./pdiff');

var INDENT = '  ';
var FIG_TICK = figures.tick;
var FIG_CROSS = figures.cross;

function createReporter() {
  var output = through2();
  var p = parser();
  var stream = duplexer(p, output);
  var startedAt = Date.now();

  var println = function println(input, indentLevel) {
    input = input || '';
    indentLevel = indentLevel || 0;
    var indent = '';

    for (var i = 0; i < indentLevel; ++i) {
      indent += INDENT;
    }

    input.split('\n').forEach(function (line) {
      output.push('' + indent + line);
      output.push('\n');
    });
  };

  var handleTest = function handleTest(name) {
    println();
    println(chalk.blue(name), 1);
  };

  var handleAssertSuccess = function handleAssertSuccess(assert) {
    var name = assert.name;

    println(chalk.green(FIG_TICK) + '  ' + chalk.dim(name), 2);
  };

  var toString = function toString(arg) {
    return Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
  };

  var JSONize = function JSONize(str) {
    return str
    // wrap keys without quote with valid double quote
    .replace(/([\$\w]+)\s*:/g, function (_, $1) {
      return '"' + $1 + '":';
    })
    // replacing single quote wrapped ones to double quote
    .replace(/'([^']+)'/g, function (_, $1) {
      return '"' + $1 + '"';
    });
  };

  var handleAssertFailure = function handleAssertFailure(assert) {
    var name = assert.name;

    var writeDiff = function writeDiff(opts) {
      opts = opts || {};
      var style = chalk.white;

      if (opts.added) style = chalk.green.inverse;
      if (opts.removed) style = chalk.red.inverse;

      // only highlight values and not spaces before
      return opts.value.replace(/(^\s*)(.*)/g, function (m, one, two) {
        return one + style(two);
      });
    };

    function decodeNewlines(str) {
      if (str.match(/([^\\])\\n/g)) return decodeNewlines(str.replace(/([^\\])\\n/g, '$1\n'));
      return str;
    }

    var diffStrings = function diffStrings(actual, expected) {
      var padding = '       ';
      var line = 1;
      var diff_ = pdiff.addLineNumbers(pdiff.diff(decodeNewlines(actual), decodeNewlines(expected)));
      var diff = pdiff.extractDiff(diff_, line);
      var maxLine = diff_.length;
      var digit = String(maxLine).length;
      var spaces = '';
      for (var i = 0; i < digit - 1; i++) {
        spaces += ' ';
      }println('');
      diff.forEach(function (group, i) {
        group.forEach(function (delta) {
          var text = padding;
          // Add line numbers
          if (delta.lineNumberOfLhs != undefined) {
            text += chalk.magenta((spaces + (delta.lineNumberOfLhs + 1)).substr(-digit));
          } else {
            text += spaces + chalk.magenta('-');
          }
          text += ' ';
          if (delta.lineNumberOfRhs != undefined) {
            text += chalk.magenta((spaces + (delta.lineNumberOfRhs + 1)).substr(-digit));
          } else {
            text += spaces + chalk.magenta('-');
          }
          text += ' ';

          // Add the value of this line
          delta.values.forEach(function (value) {
            if (value.added) {
              text += chalk.green.inverse(value.value);
              return;
            }
            if (value.removed) {
              text += chalk.red.inverse(value.value);
              return;
            }
            text += chalk.dim(value.value);
          });

          // Ouput the delta
          println(text);
        });

        if (i != diff.length - 1) {
          println(padding + chalk.dim('...'));
        }
      });
      println('');
    };

    var at = assert.diag.at;
    var actual = assert.diag.actual;
    var expected = assert.diag.expected;

    var expected_type = toString(expected);

    if (expected_type !== 'array') {
      try {
        // the assert event only returns strings which is broken so this
        // handles converting strings into objects
        if (expected.indexOf('{') > -1) {
          actual = (0, _stringify2.default)(JSON.parse(JSONize(actual)), null, 2);
          expected = (0, _stringify2.default)(JSON.parse(JSONize(expected)), null, 2);
        }
      } catch (e) {
        try {
          actual = (0, _stringify2.default)(eval('(' + actual + ')'), null, 2);
          expected = (0, _stringify2.default)(eval('(' + expected + ')'), null, 2);
        } catch (e) {
          // do nothing because it wasn't a valid json object
        }
      }

      expected_type = toString(expected);
    }

    println(chalk.red(FIG_CROSS) + '  ' + chalk.red(name) + ' at ' + chalk.magenta(at), 2);

    if (expected_type === 'object') {
      var delta = jsondiffpatch.diff(actual[failed_test_number], expected[failed_test_number]);
      var _output = jsondiffpatch.formatters.console.format(delta);
      println(_output, 4);
    } else if (expected_type === 'array') {
      var compared = diff.diffJson(actual, expected).map(writeDiff).join('');

      println(compared, 4);
    } else if (expected === 'undefined' && actual === 'undefined') {
      ;
    } else if (expected_type === 'string') {
      diffStrings(actual, expected);
    } else {
      println(chalk.red.inverse(actual) + chalk.green.inverse(expected), 4);
    }
  };

  var handleComplete = function handleComplete(result) {
    var finishedAt = Date.now();

    println();
    println(chalk.green('passed: ' + result.pass + '  ') + chalk.red('failed: ' + (result.fail || 0) + '  ') + chalk.white('of ' + result.count + ' tests  ') + chalk.dim('(' + prettyMs(finishedAt - startedAt) + ')'));
    println();

    if (result.ok) {
      println(chalk.green('All of ' + result.count + ' tests passed!'));
    } else {
      println(chalk.red((result.fail || 0) + ' of ' + result.count + ' tests failed.'));
      stream.isFailed = true;
    }

    println();
  };

  p.on('comment', function (comment) {
    var trimmed = comment.replace('# ', '').trim();

    if (/^tests\s+[0-9]+$/.test(trimmed)) return;
    if (/^pass\s+[0-9]+$/.test(trimmed)) return;
    if (/^fail\s+[0-9]+$/.test(trimmed)) return;
    if (/^ok$/.test(trimmed)) return;

    handleTest(trimmed);
  });

  p.on('assert', function (assert) {
    if (assert.ok) return handleAssertSuccess(assert);

    handleAssertFailure(assert);
  });

  p.on('complete', handleComplete);

  p.on('child', function (child) {
    ;
  });

  p.on('extra', function (extra) {
    println(chalk.yellow(('' + extra).replace(/\n$/, '')), 4);
  });

  return stream;
};
module.exports = exports['default'];