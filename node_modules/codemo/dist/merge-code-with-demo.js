'use strict';

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = mergeCodeWithDemo;

var consoleStringify = require('./console-stringify');
var partition = require('lodash.partition');
var acorn = require('acorn');
var walk = require('acorn/dist/walk');
var position = require('file-position');

function mergeCodeWithDemo(opts) {
  var codeLines = splitIntoLines(opts.code);
  var sOutputs = moveOutputsBeloveStatement(opts.outputs, codeLines, opts.code);

  return codeLines.reduce(function (acc, line, index) {
    var lineNo = index + 1;
    var partResult = partition(acc.outputs, ['line', lineNo]);
    var lineOutputs = partResult[0];
    return {
      outputs: partResult[1],
      codeLines: acc.codeLines.concat(line).concat(outputsToDemo(lineOutputs, {
        prevLine: line
      }))
    };
  }, {
    codeLines: [],
    outputs: sOutputs
  }).codeLines.join('\n');
}

function outputsToDemo(lineOutputs, opts) {
  if (!lineOutputs.length) return [];

  opts = opts || {};
  var prevLinePadding = getLinePadding(opts.prevLine);
  return lineOutputs.map(function (lineOutput) {
    return lineOutput.args;
  }).map(function (outputArgs) {
    return consoleStringify.apply(null, outputArgs);
  }).map(function (output) {
    return outputToDemo(output, {
      prevLinePadding: prevLinePadding
    });
  });
}

function getLinePadding(line) {
  var matches = (line || '').match(/^(\s*)/);
  return matches && matches[0] || '';
}

function outputToDemo(output, opts) {
  var padding = opts.prevLinePadding;
  return padding + '//> ' + output.replace(/\r?\n/g, '\n' + padding + '//  ');
}

function moveOutputsBeloveStatement(outputs, codeLines, content) {
  var ast = acorn.parse(content, { locations: true, sourceType: 'module' });
  var getPosition = position(content);

  return outputs.reduce(function (semanticOutput, output) {
    var pos = getPosition(output.line - 1, output.column);
    var semanticLineNo = outputSemanticPosition(ast, pos);
    return semanticOutput.concat((0, _assign2.default)({}, output, {
      line: semanticLineNo
    }));
  }, []);
}

function splitIntoLines(txt) {
  return txt.split('\n');
}

function outputSemanticPosition(ast, pos) {
  var node = walk.findNodeAround(ast, pos, 'ExpressionStatement');
  return node.node.loc.end.line;
}