'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.default = tokenizeList;

var _isNumeric = require('../is-numeric');

var _isNumeric2 = _interopRequireDefault(_isNumeric);

var _nodeTypes = require('../node-types');

var _nodeTypes2 = _interopRequireDefault(_nodeTypes);

var _trim = require('trim');

var _trim2 = _interopRequireDefault(_trim);

var _tryBlockTokenize = require('../try-block-tokenize');

var _tryBlockTokenize2 = _interopRequireDefault(_tryBlockTokenize);

var _sharedConstants = require('../shared-constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * A map of characters which can be used to mark
 * list-items.
 */

var LIST_UNORDERED_MARKERS = {};

LIST_UNORDERED_MARKERS['*'] = true;
LIST_UNORDERED_MARKERS['+'] = true;
LIST_UNORDERED_MARKERS['-'] = true;

/*
 * A map of characters which can be used to mark
 * list-items after a digit.
 */

var LIST_ORDERED_MARKERS = {};

LIST_ORDERED_MARKERS['.'] = true;

/*
 * A map of characters which can be used to mark
 * list-items after a digit.
 */

var LIST_ORDERED_COMMONMARK_MARKERS = {};

LIST_ORDERED_COMMONMARK_MARKERS['.'] = true;
LIST_ORDERED_COMMONMARK_MARKERS[')'] = true;

/**
 * Tokenise a list.
 *
 * @example
 *   tokenizeList(eat, '- Foo')
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `list` node.
 */
function tokenizeList(parser, value, silent) {
  var commonmark = parser.options.commonmark;
  var pedantic = parser.options.pedantic;
  var markers = void 0;
  var index = 0;
  var length = value.length;
  var start = null;
  var queue = void 0;
  var ordered = void 0;
  var character = void 0;
  var marker = void 0;
  var nextIndex = void 0;
  var startIndex = void 0;
  var prefixed = void 0;
  var currentMarker = void 0;
  var content = void 0;
  var line = void 0;
  var prevEmpty = void 0;
  var empty = void 0;
  var items = void 0;
  var allLines = void 0;
  var emptyLines = void 0;
  var item = void 0;
  var enterTop = void 0;
  var exitBlockquote = void 0;
  var isLoose = void 0;
  var now = void 0;
  var end = void 0;
  var indented = void 0;
  var size = void 0;

  while (index < length) {
    character = value.charAt(index);

    if (character !== ' ' && character !== '\t') {
      break;
    }

    index++;
  }

  character = value.charAt(index);

  markers = commonmark ? LIST_ORDERED_COMMONMARK_MARKERS : LIST_ORDERED_MARKERS;

  if (LIST_UNORDERED_MARKERS[character] === true) {
    marker = character;
    ordered = false;
  } else {
    ordered = true;
    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (!(0, _isNumeric2.default)(character)) {
        break;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (!queue || markers[character] !== true) {
      return;
    }

    start = parseInt(queue, 10);
    marker = character;
  }

  character = value.charAt(++index);

  if (character !== ' ' && character !== '\t') {
    return;
  }

  if (silent) {
    return true;
  }

  index = 0;
  items = [];
  allLines = [];
  emptyLines = [];

  return tokenizeEach(index).then(function () {
    return parser.eat(allLines.join('\n')).reset({
      type: _nodeTypes2.default.LIST,
      ordered: ordered,
      start: start,
      loose: null,
      children: []
    });
  }).then(function (node) {
    enterTop = parser.state.exitTop();
    exitBlockquote = parser.state.enterBlockquote();
    isLoose = false;
    length = items.length;
    var parent = node;

    return tokenizeEach(items).then(function () {
      enterTop();
      exitBlockquote();

      node.loose = isLoose;

      return node;
    });

    function tokenizeEach(items) {
      var rawItem = items.shift();
      if (!rawItem) return;
      var item = rawItem.value.join('\n');
      now = parser.eat.now();

      return parser.eat(item)(parser.renderListItem(item, now), parent).then(function (item) {
        if (item.loose) {
          isLoose = true;
        }

        item = rawItem.trail.join('\n');

        if (items.length) {
          item += '\n';
        }

        parser.eat(item);

        return tokenizeEach(items);
      });
    }
  });

  function tokenizeEach(index) {
    if (index >= length) return _promise2.default.resolve();

    nextIndex = value.indexOf('\n', index);
    startIndex = index;
    prefixed = false;
    indented = false;

    if (nextIndex === -1) {
      nextIndex = length;
    }

    end = index + _sharedConstants.TAB_SIZE;
    size = 0;

    while (index < length) {
      character = value.charAt(index);

      if (character === '\t') {
        size += _sharedConstants.TAB_SIZE - size % _sharedConstants.TAB_SIZE;
      } else if (character === ' ') {
        size++;
      } else {
        break;
      }

      index++;
    }

    if (size >= _sharedConstants.TAB_SIZE) {
      indented = true;
    }

    if (item && size >= item.indent) {
      indented = true;
    }

    character = value.charAt(index);
    currentMarker = null;

    if (!indented) {
      if (LIST_UNORDERED_MARKERS[character] === true) {
        currentMarker = character;
        index++;
        size++;
      } else {
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (!(0, _isNumeric2.default)(character)) {
            break;
          }

          queue += character;
          index++;
        }

        character = value.charAt(index);
        index++;

        if (queue && markers[character] === true) {
          currentMarker = character;
          size += queue.length + 1;
        }
      }

      if (currentMarker) {
        character = value.charAt(index);

        if (character === '\t') {
          size += _sharedConstants.TAB_SIZE - size % _sharedConstants.TAB_SIZE;
          index++;
        } else if (character === ' ') {
          end = index + _sharedConstants.TAB_SIZE;

          while (index < end) {
            if (value.charAt(index) !== ' ') {
              break;
            }

            index++;
            size++;
          }

          if (index === end && value.charAt(index) === ' ') {
            index -= _sharedConstants.TAB_SIZE - 1;
            size -= _sharedConstants.TAB_SIZE - 1;
          }
        } else if (character !== '\n' && character !== '') {
          currentMarker = null;
        }
      }
    }

    if (currentMarker) {
      if (commonmark && marker !== currentMarker) {
        return _promise2.default.resolve();
      }

      prefixed = true;
    } else {
      if (!commonmark && !indented && value.charAt(startIndex) === ' ') {
        indented = true;
      } else if (commonmark && item) {
        indented = size >= item.indent || size > _sharedConstants.TAB_SIZE;
      }

      prefixed = false;
      index = startIndex;
    }

    line = value.slice(startIndex, nextIndex);
    content = startIndex === index ? line : value.slice(index, nextIndex);

    if (currentMarker && _sharedConstants.RULE_MARKERS[currentMarker] === true) {
      return (0, _tryBlockTokenize2.default)(parser, 'thematicBreak', line, true).then(function (found) {
        if (found) {
          return;
        }
        return notRuleMarker();
      });
    }

    return notRuleMarker();

    function defaultEnd() {
      index = nextIndex + 1;
      return tokenizeEach(index);
    }

    function next() {
      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];

      return defaultEnd();
    }

    function notCommonmarkNext() {
      if (!commonmark) {
        return (0, _tryBlockTokenize2.default)(parser, 'definition', line, true).then(function (found) {
          if (found) return;

          return (0, _tryBlockTokenize2.default)(parser, 'footnoteDefinition', line, true).then(function (found) {
            if (found) return;

            return next();
          });
        });
      }

      return next();
    }

    function notRuleMarker() {
      prevEmpty = empty;
      empty = !(0, _trim2.default)(content).length;

      if (indented && item) {
        item.value = item.value.concat(emptyLines, line);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      } else if (prefixed) {
        if (emptyLines.length) {
          item.value.push('');
          item.trail = emptyLines.concat();
        }

        item = {
          // 'bullet': value.slice(startIndex, index),
          value: [line],
          indent: size,
          trail: []
        };

        items.push(item);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      } else if (empty) {
        // TODO: disable when in pedantic-mode.
        if (prevEmpty) {
          return _promise2.default.resolve();
        }

        emptyLines.push(line);
      } else {
        if (prevEmpty) {
          return _promise2.default.resolve();
        }

        if (!pedantic) {
          return (0, _tryBlockTokenize2.default)(parser, 'fences', line, true).then(function (found) {
            if (found) return;

            return (0, _tryBlockTokenize2.default)(parser, 'thematicBreak', line, true).then(function (found) {
              if (found) return;

              return notCommonmarkNext();
            });
          });
        }

        return notCommonmarkNext();
      }

      return defaultEnd();
    }
  }
}
module.exports = exports['default'];