'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.default = tokenizeParagraph;

var _trim = require('trim');

var _trim2 = _interopRequireDefault(_trim);

var _trimTrailingLines = require('trim-trailing-lines');

var _trimTrailingLines2 = _interopRequireDefault(_trimTrailingLines);

var _nodeTypes = require('../node-types');

var _nodeTypes2 = _interopRequireDefault(_nodeTypes);

var _tryBlockTokenize = require('../try-block-tokenize');

var _tryBlockTokenize2 = _interopRequireDefault(_tryBlockTokenize);

var _sharedConstants = require('../shared-constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Tokenise a paragraph node.
 *
 * @example
 *   tokenizeParagraph(eat, 'Foo.')
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `paragraph` node.
 */
function tokenizeParagraph(parser, value, silent) {
  var settings = parser.options;
  var commonmark = settings.commonmark;
  var gfm = settings.gfm;
  var index = value.indexOf('\n');
  var length = value.length;
  var position = void 0;
  var subvalue = void 0;
  var character = void 0;
  var size = void 0;
  var now = void 0;

  return tokenizeEach(index).then(function (index) {
    subvalue = value.slice(0, index);

    if ((0, _trim2.default)(subvalue) === '') {
      parser.eat(subvalue);

      return null;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
      return true;
    }

    now = parser.eat.now();
    subvalue = (0, _trimTrailingLines2.default)(subvalue);

    return parser.eat(subvalue)(parser.renderInline(_nodeTypes2.default.PARAGRAPH, subvalue, now));
  });

  function tokenizeEach(index) {
    /*
     * Eat everything if thereâ€™s no following newline.
     */

    if (index === -1) return _promise2.default.resolve(length);

    /*
     * Stop if the next character is NEWLINE.
     */

    if (value.charAt(index + 1) === '\n') {
      return _promise2.default.resolve(index);
    }

    /*
     * In commonmark-mode, following indented lines
     * are part of the paragraph.
     */

    if (commonmark) {
      size = 0;
      position = index + 1;

      while (position < length) {
        character = value.charAt(position);

        if (character === '\t') {
          size = _sharedConstants.TAB_SIZE;
          break;
        } else if (character === ' ') {
          size++;
        } else {
          break;
        }

        position++;
      }

      if (size >= _sharedConstants.TAB_SIZE) {
        index = value.indexOf('\n', index + 1);
        return tokenizeEach(index);
      }
    }

    /*
     * Check if the following code contains a possible
     * block.
     */

    subvalue = value.slice(index + 1);

    return (0, _tryBlockTokenize2.default)(parser, 'thematicBreak', subvalue, true).then(function (found) {
      if (found) return index;

      return (0, _tryBlockTokenize2.default)(parser, 'heading', subvalue, true).then(function (found) {
        if (found) return index;

        return (0, _tryBlockTokenize2.default)(parser, 'fences', subvalue, true).then(function (found) {
          if (found) return index;

          return (0, _tryBlockTokenize2.default)(parser, 'blockquote', subvalue, true).then(function (found) {
            if (found) return index;

            return (0, _tryBlockTokenize2.default)(parser, 'html', subvalue, true).then(function (found) {
              if (found) return index;

              if (gfm) {
                return (0, _tryBlockTokenize2.default)(parser, 'list', subvalue, true).then(function (found) {
                  if (found) return index;

                  return lastCheck();
                });
              }

              return lastCheck();
            });
          });
        });
      });
    });

    function lastCheck() {
      if (!commonmark) {
        return (0, _tryBlockTokenize2.default)(parser, 'lineHeading', subvalue, true).then(function (found) {
          if (found) return index;

          return (0, _tryBlockTokenize2.default)(parser, 'definition', subvalue, true).then(function (found) {
            if (found) return index;

            return (0, _tryBlockTokenize2.default)(parser, 'footnoteDefinition', subvalue, true).then(function (found) {
              if (found) return index;

              return defaultEnd();
            });
          });
        });
      }

      return defaultEnd();
    }

    function defaultEnd() {
      index = value.indexOf('\n', index + 1);
      return tokenizeEach(index);
    }
  }
}
module.exports = exports['default'];