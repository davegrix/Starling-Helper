'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _nodeTypes = require('../node-types');

var _nodeTypes2 = _interopRequireDefault(_nodeTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = tokenizeBreak;


var MIN_BREAK_LENGTH = 2;

/**
 * Find a possible break.
 *
 * @example
 *   locateBreak('foo   \nbar') // 3
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible break.
 */
function locateBreak(parser, value, fromIndex) {
  var index = value.indexOf('\n', fromIndex);

  while (index > fromIndex) {
    if (value.charAt(index - 1) !== ' ') {
      break;
    }

    index--;
  }

  return index;
}

/**
 * Tokenise a break.
 *
 * @example
 *   tokenizeBreak(eat, '  \n')
 *
 * @property {Function} locator - Break locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `break` node.
 */
function tokenizeBreak(parser, value, silent) {
  var breaks = parser.options.breaks;
  var index = -1;
  var queue = '';

  while (++index < value.length) {
    var character = value.charAt(index);

    if (character === '\n') {
      if (!breaks && index < MIN_BREAK_LENGTH) {
        return;
      }

      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true;
      }

      queue += character;
      return parser.eat(queue)({
        type: _nodeTypes2.default.BREAK
      });
    }

    if (character !== ' ') {
      return;
    }

    queue += character;
  }
}

tokenizeBreak.locator = locateBreak;
module.exports = exports['default'];