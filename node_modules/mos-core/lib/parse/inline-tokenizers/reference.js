'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _link = require('./locators/link');

var _link2 = _interopRequireDefault(_link);

var _nodeTypes = require('../node-types');

var _nodeTypes2 = _interopRequireDefault(_nodeTypes);

var _isWhiteSpace = require('../is-white-space');

var _isWhiteSpace2 = _interopRequireDefault(_isWhiteSpace);

var _utilities = require('../../utilities.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = tokenizeReference;


/*
 * Available reference types.
 */

var REFERENCE_TYPE_SHORTCUT = 'shortcut';
var REFERENCE_TYPE_COLLAPSED = 'collapsed';
var REFERENCE_TYPE_FULL = 'full';

/**
 * Tokenise a reference link, image, or footnote
 * shortcut reference link, or footnote.
 *
 * @example
 *   tokenizeReference(eat, '[foo]')
 *   tokenizeReference(eat, '[foo][]')
 *   tokenizeReference(eat, '[foo][bar]')
 *
 * @property {Function} locator - Reference locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - Reference node.
 */
function tokenizeReference(parser, value, silent) {
  var character = value.charAt(0);
  var index = 0;
  var length = value.length;
  var subvalue = '';
  var intro = '';
  var type = _nodeTypes2.default.LINK;
  var referenceType = REFERENCE_TYPE_SHORTCUT;

  /*
   * Check whether we’re eating an image.
   */

  if (character === '!') {
    type = _nodeTypes2.default.IMAGE;
    intro = character;
    character = value.charAt(++index);
  }

  if (character !== '[') {
    return;
  }

  index++;
  intro += character;
  var queue = '';

  /*
   * Check whether we’re eating a footnote.
   */

  if (parser.options.footnotes && type === _nodeTypes2.default.LINK && value.charAt(index) === '^') {
    intro += '^';
    index++;
    type = _nodeTypes2.default.FOOTNOTE;
  }

  /*
   * Eat the text.
   */

  var depth = 0;
  var bracketed = void 0;

  while (index < length) {
    character = value.charAt(index);

    if (character === '[') {
      bracketed = true;
      depth++;
    } else if (character === ']') {
      if (!depth) {
        break;
      }

      depth--;
    }

    if (character === '\\') {
      queue += '\\';
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }

  var text = void 0;
  subvalue = text = queue;
  character = value.charAt(index);

  if (character !== ']') {
    return;
  }

  index++;
  subvalue += character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!(0, _isWhiteSpace2.default)(character)) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);

  var identifier = void 0;
  if (character !== '[') {
    if (!text) {
      return;
    }

    identifier = text;
  } else {
    identifier = '';
    queue += character;
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (character === '[' || character === ']') {
        break;
      }

      if (character === '\\') {
        identifier += '\\';
        character = value.charAt(++index);
      }

      identifier += character;
      index++;
    }

    character = value.charAt(index);

    if (character === ']') {
      queue += identifier + character;
      index++;

      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;
    } else {
      identifier = '';
    }

    subvalue += queue;
    queue = '';
  }

  /*
   * Brackets cannot be inside the identifier.
   */

  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {
    return;
  }

  /*
   * Inline footnotes cannot have an identifier.
   */

  if (type === _nodeTypes2.default.FOOTNOTE && referenceType !== REFERENCE_TYPE_SHORTCUT) {
    type = _nodeTypes2.default.LINK;
    intro = '[^';
    text = '^' + text;
  }

  subvalue = intro + subvalue;

  if (type === _nodeTypes2.default.LINK && parser.state.inLink) {
    return null;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  if (type === _nodeTypes2.default.FOOTNOTE && text.indexOf(' ') !== -1) {
    return parser.eat(subvalue)(parser.renderFootnote(text, parser.eat.now()));
  }

  var now = parser.eat.now();
  now.column += intro.length;
  now.offset += intro.length;
  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : text;

  var node = {
    type: type + 'Reference',
    identifier: (0, _utilities.normalizeIdentifier)(identifier)
  };

  if (type === _nodeTypes2.default.LINK || type === _nodeTypes2.default.IMAGE) {
    node.referenceType = referenceType;
  }

  if (type === _nodeTypes2.default.LINK) {
    var _ret = function () {
      var exitLink = parser.state.enterLink();
      return {
        v: parser.tokenizeInline(text, now).then(function (children) {
          node.children = children;
          exitLink();
          return parser.eat(subvalue)(node);
        })
      };
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
  }

  if (type === _nodeTypes2.default.IMAGE) {
    node.alt = parser.decode.raw(parser.descape(text), now) || null;
    return parser.eat(subvalue)(node);
  }

  return parser.eat(subvalue)(node);
}

tokenizeReference.locator = _link2.default;
module.exports = exports['default'];