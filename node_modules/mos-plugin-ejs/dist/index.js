'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

exports.default = plugin;

var _createAsyncScopeEval = require('./create-async-scope-eval');

var _createAsyncScopeEval2 = _interopRequireDefault(_createAsyncScopeEval);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var template = new RegExp('^<!--@([\\s\\S]+?)-->(?:[\\s\\S]*?)<!--/@-->');

function matchRecursive(str) {
  var iterator = new RegExp('(<!--@([\\s\\S]+?)-->)|(<!--/@-->)', 'g');
  var openTokens = void 0,
      matchStartIndex = void 0,
      match = void 0;

  do {
    openTokens = 0;
    var firstMatch = void 0;
    var code = void 0;
    while (match = iterator.exec(str)) {
      var inside = str.slice(matchStartIndex, match.index);
      var insideFencedBlock = (inside.match(/```/g) || []).length % 2 !== 0;
      if (insideFencedBlock) continue;

      if (~match[0].indexOf('<!--@')) {
        if (!openTokens) {
          matchStartIndex = iterator.lastIndex;
          firstMatch = match[0];
          code = match[2];
        }
        openTokens++;
        continue;
      }
      if (openTokens) {
        openTokens--;
        if (!openTokens) {
          return [firstMatch + inside + match[0], code];
        }
      }
    }
  } while (openTokens && (iterator.lastIndex = matchStartIndex));
}

function plugin(mos, md) {
  function markdownScript(parser, value, silent) {
    if (!template.exec(value)) return;

    var match = matchRecursive(value);

    if (match) {
      if (silent) return true;

      return generateMarkdown(parser, match[1]).catch(function (err) {
        var wraperr = new Error('Failed to execute template code at line ' + parser.eat.now().line + ' with \'' + err.message + '\'');
        wraperr.initialError = err;
        throw wraperr;
      }).then(function (children) {
        return parser.eat(match[0])({
          type: 'markdownScript',
          code: match[1],
          children: children
        });
      });
    }
  }

  markdownScript.locator = function (parser, value, fromIndex) {
    return value.indexOf('<!--@', fromIndex);
  };

  mos.visitors.markdownScript = function (compiler, node) {
    var body = mos.visitors.block(compiler, node);
    var bodyWithNL = body ? '\n' + body + '\n' : body;
    if (node.children && node.children.length && node.children[node.children.length - 1].type === 'list') {
      bodyWithNL += '\n';
    }
    return '<!--@' + node.code + '-->' + bodyWithNL + '<!--/@-->';
  };

  mos.inlineTokenizers.splice(0, 0, {
    name: 'markdownScript',
    func: markdownScript
  });
  mos.blockTokenizers.splice(0, 0, {
    name: 'markdownScript',
    func: markdownScript
  });

  function generateMarkdown(parser, code) {
    return parser.file.asyncScopeEval(code).then(function (ast) {
      if (ast instanceof Array) return ast;
      if ((typeof ast === 'undefined' ? 'undefined' : (0, _typeof3.default)(ast)) === 'object') return [ast];
      parser.offset = parser.offset || {};
      return parser.tokenizeBlock(ast.toString());
    });
  }

  mos.root.scope = {};

  mos.parse.pre(function (next, md, opts) {
    md.vfile.asyncScopeEval = (0, _createAsyncScopeEval2.default)(mos.root.scope, {
      useStrict: true
    });
    return next.applySame();
  });
}

plugin.attributes = {
  pkg: require('../package.json')
};
module.exports = exports['default'];