'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var describe = require('mocha').describe;
var it = require('mocha').it;
var expect = require('chai').expect;
var mos = require('mos-processor');


function createProcess(scope) {
  var plugin1 = function plugin1(mos) {
    return (0, _assign2.default)(mos.scope, scope || {});
  };
  plugin1.attributes = {
    name: 'plugin1'
  };
  return function (md) {
    return mos({ content: md, filePath: __filename }, [_index2.default, plugin1]).then(function (processor) {
      return processor.process();
    });
  };
}

describe('mos', function () {
  it('should insert value to markdown when no value in the placeholder', function () {
    var process = createProcess({
      pkg: {
        name: 'foo'
      }
    });
    return process('Insert <!--@pkg.name--><!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('Insert <!--@pkg.name-->\nfoo\n<!--/@--> here\n');
    });
  });

  it('should insert value to markdown when the plugin returns a promise', function () {
    var process = createProcess({
      asyncFoo: function asyncFoo() {
        return _promise2.default.resolve('foo');
      }
    });
    return process('Insert <!--@asyncFoo()--><!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('Insert <!--@asyncFoo()-->\nfoo\n<!--/@--> here\n');
    });
  });

  it('should insert value to markdown when there is already a value in the placeholder', function () {
    var process = createProcess({
      pkg: {
        name: 'foo'
      }
    });
    return process('Insert <!--@pkg.name-->bar<!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('Insert <!--@pkg.name-->\nfoo\n<!--/@--> here\n');
    });
  });

  it('should insert value with newline to markdown', function () {
    var process = createProcess({
      pkg: {
        name: 'new\nvalue'
      }
    });
    return process('Insert <!--@pkg.name-->old\nvalue<!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('Insert <!--@pkg.name-->\nnew\nvalue\n<!--/@--> here\n');
    });
  });

  it('should execute javascript and insert into the markup', function () {
    var process = createProcess();
    return process('Insert <!--@ 1 + 2 --><!--/@--> here').then(function (newMD) {
      return expect(newMD).to.eq('Insert <!--@ 1 + 2 -->\n3\n<!--/@--> here\n');
    });
  });

  it('should execute javascript when it contains newlines', function () {
    var process = createProcess();
    return process('Insert\n\n<!--@\n\n1 + 2 --><!--/@-->\n\nhere').then(function (newMD) {
      return expect(newMD).to.eq('Insert\n\n<!--@\n\n1 + 2 -->\n3\n<!--/@-->\n\nhere\n');
    });
  });

  it('should match several inputs', function () {
    var process = createProcess();
    return process('Insert\n\n<!--@\n\n1 + 2 --><!--/@-->\n\nhere\n\n<!--@"Hello world!"-->"Hello world!"<!--/@-->\n').then(function (newMD) {
      return expect(newMD).to.eq('Insert\n\n<!--@\n\n1 + 2 -->\n3\n<!--/@-->\n\nhere\n\n<!--@"Hello world!"-->\nHello world!\n<!--/@-->\n');
    });
  });

  it('should not insert value to markdown comments that are inside code blocks', function () {
    var process = createProcess({
      pkg: {
        name: 'foo'
      }
    });
    return process('Do not insert\n``` md\n<!--@pkg.name--><!--/@-->\n```\nhere').then(function (newMD) {
      expect(newMD).to.eq('Do not insert\n\n```md\n<!--@pkg.name--><!--/@-->\n```\n\nhere\n');
    });
  });

  it('should insert value to markdown when comments are after code blocks', function () {
    var process = createProcess({
      pkg: {
        name: 'foo'
      }
    });
    return process('```\nInsert\n```\n\n<!--@pkg.name--><!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('    Insert\n\n<!--@pkg.name-->\nfoo\n<!--/@-->\n\n here\n');
    });
  });

  it('should throw exception when error during template code execution', function (done) {
    var process = createProcess();
    return process('<!--@1/--><!--/@-->').catch(function (err) {
      expect(err).to.be.instanceOf(Error);
      expect(err.message).to.match(/Failed to execute template code at line 1/);
      done();
    });
  });

  it('should insert value to markdown and override nested markdown scripts', function () {
    var process = createProcess({
      pkg: {
        name: 'foo'
      }
    });
    return process('Insert <!--@pkg.name--><!--@pkg.name--><!--/@--><!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('Insert <!--@pkg.name-->\nfoo\n<!--/@--> here\n');
    });
  });

  it('should ignore closing tag that is inside a fenced block', function () {
    var process = createProcess({
      pkg: {
        name: 'foo'
      }
    });
    return process('<!--@pkg.name-->\n```\n<!--/@-->\n```\n<!--/@-->').then(function (newMD) {
      expect(newMD).to.eq('<!--@pkg.name-->\nfoo\n<!--/@-->\n');
    });
  });

  it('should insert value to markdown and override nested markdown scripts that are inside fenced blocks', function () {
    var process = createProcess();
    return process('<!--@"foo"-->\n```\n<!--@pkg.name--><!--/@-->\n```\n<!--/@-->').then(function (newMD) {
      expect(newMD).to.eq('<!--@"foo"-->\nfoo\n<!--/@-->\n');
    });
  });

  it('should insert convert AST to markdown and insert it', function () {
    var process = createProcess({
      ast: {
        type: 'paragraph',
        children: [{
          type: 'text',
          value: 'foo'
        }]
      }
    });
    return process('Insert <!--@ ast --><!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('Insert <!--@ ast -->\nfoo\n<!--/@--> here\n');
    });
  });

  it('should insert additional break after list', function () {
    var process = createProcess({
      ast: {
        type: 'list',
        ordered: false,
        children: [{
          type: 'listItem',
          children: [{
            type: 'text',
            value: 'foo'
          }]
        }]
      }
    });
    return process('Insert <!--@ ast --><!--/@--> here').then(function (newMD) {
      expect(newMD).to.eq('Insert <!--@ ast -->\n- foo\n\n<!--/@--> here\n');
    });
  });

  describe('stringify', function () {
    it('should stringify markdownScript with no children', function (done) {
      return mos({}, [_index2.default]).then(function (processor) {
        return processor.compile({
          type: 'markdownScript',
          code: 'foo',
          children: []
        });
      }).then(function (result) {
        expect(result).to.eq('<!--@foo--><!--/@-->');
        done();
      }).catch(done);
    });
  });
});